<% escapeMarkup = false %>
<%
	import ru.neoflex.datalog.engine.dto.DestTable

	import scala.collection.mutable.ListBuffer
	import scala.reflect.io.Path
	import scala.io.Codec
	import Path._
	import scala.xml._
	import ru.neoflex.datalog.engine.{Parser, LineProcessor, SqlScriptLineProcessor}
	import org.json4s._
	import org.json4s.jackson.JsonMethods._
	import org.json4s.jackson.Serialization
	%>
<%@ val params: Option[String] = None%>
<%
	implicit val formats = DefaultFormats

	implicit val codec = Codec("UTF8")

	var joinScriptsFolder = ""
	var filesFilter = ".*\\.ktr"
	val resTables = ListBuffer[DestTable]()
	var project = ""
	var sourceFile = ""
	var deep = -1
	params.map(s => {
		val j = parse(s)
		joinScriptsFolder = (j \ "folder").extract[String]
		project = (j \ "project").extract[String]
		sourceFile = (j \ "sourcePrefix").extract[String]
		(j \ "deep").toOption.map(v=> deep = v.extract[Int])
		(j \ "filesFilter").toOption.map(v=> filesFilter = v.extract[String])
	})
	val stepList = ListBuffer[String]()

	val  folder = "C:\\projects\\temp\\ac\\localRep"

	def resTable(tname: String, tables: ListBuffer[DestTable], fromStep: String = "",  toStep: String = "", resTables: ListBuffer[DestTable]): DestTable = {
  		val fTable = tables.find(t => t.name == tname).get
		val sources: ListBuffer[String] = ListBuffer()
		sources ++= fTable.sources
  		if(fromStep != "") {
    		sources += fromStep
  		}

		if(resTables.exists(t=>t.name == tname)) {
			val f = resTables.find(t => t.name == tname).get
			resTables -= f
			sources ++= f.sources
			if(fromStep != "") {
				sources += fromStep
			}
		}
  		DestTable(tname, sources.toList.distinct, fTable.sourceFile, fTable.layer)
	}

	folder.toDirectory.deepList(deep).filter(_.isFile).filter(p=>p.path matches filesFilter)
		.foreach(file => {
			val tables = ListBuffer[DestTable]()
			val fileName = file.path
			println(fileName)
			try {
				val xml = XML.loadFile(fileName)
				val transformationName = (xml \ "info" \ "name").text
				(xml \\ "step").foreach(step => {
					val stepName = (step \ "name").text
					stepList += transformationName + "." + stepName
					(step \\ "sql").foreach(sql => {
						Parser.processSqlScript(
							sql.text
							.replace(" ?", "'?'")
							.replace("(?", "('?'")
							.replace("=?)", "='?')")
							.replace("=?", "='?'")
							.replace("as char", "as string")
							.replace("#", "--#")
							.replace("&lt;", "<")
							.replace("&gt;", ">")
							.replace(" as CHAR)", " as string)")
							.replace("as Договор,", "as Dogovor,")
							.replace("o.sum Сумма", "o.sum Summa")
							.replace("\"PKEY\"", "PKEY")
							.replace("\"CLIENT_ISSUE_KEY\"", "CLIENT_ISSUE_KEY")
							.replace("\"CLIENT_ISSUE_ID\"", "CLIENT_ISSUE_ID")
							.replace("\"AO_CE177D_NEO_BILLINGS\"", "AO_CE177D_NEO_BILLINGS")
							.replace("GROUP_CONCAT(label SEPARATOR ',')", "\"GROUP_CONCAT(label SEPARATOR ',')\"")
							.replace("DATE_SUB(NOW(),INTERVAL DAYOFMONTH(NOW())-1 DAY)", "\"DATE_SUB(NOW(),INTERVAL DAYOFMONTH(NOW())-1 DAY)\"")
							.replace("date(NOW())", "date(\"NOW()\")")
							.replace("с on с.c=b.b",  "as с(c string, workdays int) on с.c=b.b"),
							fileName.replace("\\", "\\\\"),
							tables,
							layer = transformationName,
							defaultOut = Seq(stepName)
						)
				})
			})
			(xml \\ "hop").foreach(hop => {
				val stepTo = (hop \ "to").text
				val stepFrom = (hop \ "from").text
				if(tables.exists(t => t.name == stepTo)) {
				  resTables += resTable(tname = stepTo, tables = tables, fromStep = stepFrom, resTables = resTables)
				}
				if(tables.exists(t => t.name == stepFrom)) {
				  resTables += resTable(tname = stepFrom, tables = tables, resTables = resTables)
				}
				if(!resTables.exists(t => t.name == stepTo)) {
				  resTables += DestTable(stepTo, List(stepFrom), fileName.replace("\\", "/"), transformationName)
				} else {
					val f = resTables.find(t => t.name == stepTo).get
					resTables -= f
					val sources = ListBuffer[String]()
					sources ++= f.sources
					sources += stepFrom
					resTables += DestTable(stepTo, sources.toList.distinct, fileName.replace("\\", "/"), transformationName)
				}
			})
		} catch {
			case e: Throwable => e.printStackTrace()
			case _ => println("Some error " + fileName)
		}
	})

	def getType(name: String): String = {
		if(stepList.contains(name)) {
			return "Component"
		}
		"Table"
	}
%>
{
"datasets":
	[
	#for (i <- 0 to resTables.size - 1)
		{
			"name": "${resTables(i).name}",
			"layer": "${resTables(i).layer}",
			"project": "${project}",
			"datasetType": "${getType(resTables(i).layer + '.' + resTables(i).name)}",
			"sourceFile": "${resTables(i).sourceFile}",
			"in": [
			#for(j <- 0 to resTables(i).sources.size - 1)
				{
					"name": "${resTables(i).sources(j)}",
					"layer": "${resTables(i).layer}",
					"project": "${project}",
					"sourceFile": "${resTables(i).sourceFile}",
					"datasetType": "${getType(resTables(i).layer + '.' + resTables(i).sources(j))}",
					"in": []
				}#if(j != resTables(i).sources.size - 1) , #end
			#end
			],
			"out": []
			}#if(i != resTables.size - 1) , #end
	#end
	]
}
