insert into odpp_autoqa.AutoQa_ExpInfo select inner_table.* ,'784' as `test_case_id`,  cast('2021-07-26 18:44:39.193' as TIMESTAMP)  as `test_case_datetime`,  cast('2021-07-23' as DATE) as `bdate`, 'R62' as `branch`, 'ifrs9' as `batch_id`, 'pwc_R62_2021-07-23_920ae4ba-05e7-4bc4-9a45-fbfa84c25edc' as `test_suite_uuid` from (select ex.expid, ex.clientid, ex.productid, ex.departmentid
from odpp_pwc.expinfo ex 
inner join odpp.deal_tmp0 d 
        on ex.expid = d.sourcedealid
        and ex.bdate = d.bdate
        and ex.branch = d.branch
where ex.bdate = '2021-07-23' and ex.branch = 'R62' 
and d.sourceid = 'ABS'
and d.srcmodule in ('ACCRED', 'GUAR')  
and (ex.nir != 0 or ex.nir is null) ) inner_table
<%
	import java.io.File
	import scala.collection.mutable.ListBuffer
	import scala.io.Source.fromFile
	import scala.io.Codec
	import scala.util.control.Breaks._
	import scala.io.Source
	import org.json4s._
	import org.json4s.jackson.JsonMethods._
	import ru.neoflex.datalog.engine.Parser
	%>
<%@ val params: Option[String] = None%>
<%	implicit val formats = DefaultFormats

	implicit val codec = Codec("UTF-8")

	case class DestTable(name: String, sources: List[String], sourceFile: String)

	def getListOfFiles(dir: String):List[File] = {
		val d = new File(dir)
		if (d.exists && d.isDirectory) {
			d.listFiles.filter(_.isFile).toList
		} else {
			List[File]()
		}
	}
	var joinScriptsFolder = ""
	val tables = ListBuffer[DestTable]()
	var project = ""
	var sourceFile = ""
	params.map(s => {
		val j = parse(s)
		joinScriptsFolder = (j \ "folder").extract[String]
		project = (j \ "project").extract[String]
		sourceFile = (j \ "sourcePrefix").extract[String]
	})
	//val tables = Parser.sqlTokens(joinScriptsFolder, sourceFile) //ListBuffer[DestTable]()
	val files = getListOfFiles(joinScriptsFolder)
	files.foreach(file => {
		val fn = sourceFile + file.getName()

		val source = fromFile(file.getAbsolutePath())
		val lines = source.getLines()
		var destTable = ""
		val sources = ListBuffer[String]()

		lines.foreach(s => {
			val insTokens = List("insert into", "insert overwrite")
			val fromTokens = List("from odpp", " join ")
			breakable {insTokens.foreach(insToken => {
				if(s.contains(insToken)) {
					destTable = s.replace(insToken, "").replace("table", "").trim.split(' ')(0)
					break
					}
				}
			)}
			fromTokens.foreach(token => {
				if(s.contains(token)) {
					val source = s.split(" on ")(0).split(' ').find(w => w.contains('.'))
					source.map(w =>{
						if(!sources.exists(item => item == w)) {
							sources += w
						}
					})

				}
			})
		})
		if(destTable.contains(".")) {
			tables.find(f => f.name == destTable).map(ft => {
				sources ++= ft.sources;
				tables -= ft
			})
			tables += DestTable(destTable, sources.toList.distinct, fn)
		}
		source.close()
	})
%>
{
"datasets":
	[
	#for (i <- 0 to tables.size - 1)
		{
			"name": "${tables(i).name}",
			"layer": "${tables(i).name.split('.')(0)}",
			"project": "${project}",
			"sourceFile": "${tables(i).sourceFile}",
			"in": [
			#for(j <- 0 to tables(i).sources.size - 1)
				{
					"name": "${tables(i).sources(j)}",
					"layer": "${tables(i).sources(j).split('.')(0)}",
					"project": "${project}",
					"sourceFile": "${tables(i).sourceFile}",
					"in": []
				}#if(j != tables(i).sources.size - 1) , #end
			#end
			],
			"out": [
			]
			}#if(i != tables.size - 1) , #end
	#end
	]
}
